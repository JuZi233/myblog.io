{"pages":[{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"SystemPermisson","text":"什么是权限FIBOS 账户权限有2种： owner、active，一个账户必须“关联” owner、active 权限。 owner 拥有超级权限，代表着账户的归属者，因为拥有此权限者可以用于操作其他权限配置，该权限常用事务中（转账、合约 action 等）一般不会使用。 active 常用业务的权限，比如：转账、投票等。 账户与权限的关系一个完整的账户包含如下属性： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758{ 'account_name': 'hellofibos01', 'head_block_num': 10, 'head_block_time': '2018-08-21T09:58:50.500', 'privileged': false, 'last_code_update': '1970-01-01T00:00:00.000', 'created': '2018-08-21T09:58:51.000', 'ram_quota': -1, 'net_weight': -1, 'cpu_weight': -1, 'net_limit': { 'used': -1, 'available': -1, 'max': -1 }, 'cpu_limit': { 'used': -1, 'available': -1, 'max': -1 }, 'ram_usage': 2724, 'permissions': [ { 'perm_name': 'active', 'parent': 'owner', 'required_auth': { 'threshold': 1, 'keys': [ { 'key': 'FO5dZut9MG9ZdqrT1WYdPkp1Txxi6JLRYEgYCtAUDWH6ymNqdJpR', 'weight': 1 } ], 'accounts': [], 'waits': [] } }, { 'perm_name': 'owner', 'parent': '', 'required_auth': { 'threshold': 1, 'keys': [ { 'key': 'FO5dZut9MG9ZdqrT1WYdPkp1Txxi6JLRYEgYCtAUDWH6ymNqdJpR', 'weight': 1 } ], 'accounts': [], 'waits': [] } } ], 'total_resources': null, 'self_delegated_bandwidth': null, 'refund_request': null, 'voter_info': null} 结果中 permissions 字段 owner、active 权限控制者确实是公钥FO5dZut9MG9ZdqrT1WYdPkp1Txxi6JLRYEgYCtAUDWH6ymNqdJpR 的拥有者。 分析账户与权限在新建账户的时候设置owner和active的权限对应的的公私钥值： 123456fibos.newaccountSync({ creator: 'eosio', name: name, owner: pubkey, active: pubkey}); * 以上代码可以看到把 owner、active 权限的控制权限给了公钥 FO5dZut9MG9ZdqrT1WYdPkp1Txxi6JLRYEgYCtAUDWH6ymNqdJpR，也就说此公钥对应的私钥拥有者，有 owner、active 的权限。 * 配置权限更改账户 hellofibos01 的 active 权限。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859var FIBOS = require('fibos.js');//账户 hellofibos01 的公私钥对let pubkey = 'your public key';let prikey = 'your private key';//账户 hellofibos02 的公私钥对let pubkey2 = 'your public key2';let prikey2 = 'your private key2';var name = 'hellofibos01';var name2 = 'hellofibos02';//创建 hellofibos02 账户var fibos = FIBOS({ chainId: 'cf057bbfb72640471fd910bcb67639c22df9f92470936cddc1ade0e2f2e7dc4f', keyProvider: 'your keyProvider', httpEndpoint: 'http://127.0.0.1:8888', logger: { log: null, error: null }});fibos.newaccountSync({ creator: 'eosio', name: name2, owner: pubkey2, active: pubkey2});//修改hellofibos01 的active权限,客户端 需要更改为 hellofibos01 的私钥fibos = FIBOS({ chainId: 'cf057bbfb72640471fd910bcb67639c22df9f92470936cddc1ade0e2f2e7dc4f', keyProvider: 'your private key', httpEndpoint: 'http://127.0.0.1:8888', logger: { log: null, error: null }});let ctx = fibos.contractSync('eosio');ctx.updateauthSync({ account: name, permission: 'active', parent: 'owner', auth: { threshold: 1, keys: [{ key: 'FO5UFAzxUsbjQCijL5LtS6TaTtkJgPJACZ8qwDpXyLaW3sE9Ed2D', weight: 1 }] }});var c = fibos.getAccountSync(name);console.notice(c); 输出结果如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758{ 'account_name': 'hellofibos01', 'head_block_num': 66, 'head_block_time': '2018-08-21T09:59:18.500', 'privileged': false, 'last_code_update': '1970-01-01T00:00:00.000', 'created': '2018-08-21T09:58:51.000', 'ram_quota': -1, 'net_weight': -1, 'cpu_weight': -1, 'net_limit': { 'used': -1, 'available': -1, 'max': -1 }, 'cpu_limit': { 'used': -1, 'available': -1, 'max': -1 }, 'ram_usage': 2724, 'permissions': [ { 'perm_name': 'active', 'parent': 'owner', 'required_auth': { 'threshold': 1, 'keys': [ { 'key': 'FO5UFAzxUsbjQCijL5LtS6TaTtkJgPJACZ8qwDpXyLaW3sE9Ed2D', 'weight': 1 } ], 'accounts': [], 'waits': [] } }, { 'perm_name': 'owner', 'parent': '', 'required_auth': { 'threshold': 1, 'keys': [ { 'key': 'FO5dZut9MG9ZdqrT1WYdPkp1Txxi6JLRYEgYCtAUDWH6ymNqdJpR', 'weight': 1 } ], 'accounts': [], 'waits': [] } } ], 'total_resources': null, 'self_delegated_bandwidth': null, 'refund_request': null, 'voter_info': null} 以上代码新建了账户 hellofibos02，并且调用 updateauthSync 方法，进行权限变更操作。我们把 hellofibos01 的 active 权限转移给了公钥 FO5UFAzxUsbjQCijL5LtS6TaTtkJgPJACZ8qwDpXyLaW3sE9Ed2D。 多签签名,多签及阀值我们在使用区块链进行授权操作时, 都是通过私钥进行签名的，通过确认签名来确认授权许可，多签则是将一个权限分给多个账户，设置一个阀值，每个参与的账户都有权重，当最后的权重大于等于该阀值的时候，授权通过 实例单签 权限 所属公钥 权重 阀值 owner 1 FO5dZut9MG9ZdqrT1WYdPkp1Txxi6JLRYEgYCtAUDWH6ymNqdJpR 1 - active 1 FO5dZut9MG9ZdqrT1WYdPkp1Txxi6JLRYEgYCtAUDWH6ymNqdJpR 1 - 如表所示，如果要获得 owner 权限授权，拥有者的权重必须大于等于 owner 所对应的阈值，上面的示例 owner 的阈值是1，而所属公钥 FO6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV 的权重是1，所以这个所属公钥就可以直接获取 owner 进行操作。 多签 权限 所属公钥 权重 阀值 owner 2 FO5dZut9MG9ZdqrT1WYdPkp1Txxi6JLRYEgYCtAUDWH6ymNqdJpR 1 - FO5UFAzxUsbjQCijL5LtS6TaTtkJgPJACZ8qwDpXyLaW3sE9Ed2D 1 - active 1 FO5dZut9MG9ZdqrT1WYdPkp1Txxi6JLRYEgYCtAUDWH6ymNqdJpR 1 - 如表所示，要想获得 owner 权限，必须2个所属公钥同时授权才可以获得。","link":"/2019/10/31/SystemPermisson/"},{"title":"Installing Fibos","text":"Welcome to d3j! This is your very first post. Check documentation for more info. If you get any problems when using fibos, you can find the answer in troubleshooting Quick Start安装FIBOS 支持常用的 UNIX 操作系统，比如 Mac OSX，Linux 和 FreeBSD。 建议在终端直接使用下面的命令快速安装：稳定版 1$ curl -s https://fibos.io/download/installer.sh | sh 安装结束后 FIBOS 可执行文件在系统 bin 目录下，使用查看 FIBOS 版本 12345~$ which fibos/usr/local/bin/fibos~$ fibos --versionv0.27.0-dev 常用命令直接执行 FIBOS 回车，查询版本信息，如： 123456~$ fibosWelcome to fibjs 0.26.0-dev.Type '.help' for more information.&gt; console.log('hello,FIBOS!')hello,FIBOS!&gt; .info 创建 hello_fibos 文件夹 ，生成 package.json 文件配置初始化： 12$ cd hello_fibos$ fibos --init 或者 npm init 安装包 1$ fibos --install fibos.js 或者 npm install fibos.js 升级重新执行安装命令会自动覆盖原有的 fibos 可执行文件，然后重启一下 fibos 服务即可完成升级。 卸载直接删除 /usr/local/bin/ 下的 fibos 这个可执行文件即可。 1$ sudo rm /usr/local/bin/fibos","link":"/2019/10/29/Hello-fibjs/"},{"title":"Ubuntu中使用FTP服务","text":"安装ftp服务器目前Linux上使用较多的ftp服务器是vsftpd。所以，我们需要先安装vsftpd软件。在Ubuntu上安装vsftpd，使用的命令是： 1$ sudo apt-get install vsftpd 卸载ftp服务器1$ sudo apt-get purge vsftpd vsftpd配置安装好vsftpd后，修改 /etc/vsftpd.conf文件。可参考如下配置说明: 123456789101112131415161718192021222324252627282930# 禁止匿名用户登录anonymous_enable=NO# 允许系统用户登录local_enable=YES# 启用可以修改文件的 FTP 命令write_enable=YES# 本地用户创建文件的 umask 值local_umask=022# 允许为目录配置显示信息,显示每个目录下面的message_file文件的内容dirmessage_enable=YES# 开启日记功能 xferlog_enable=YES# 使用标准的20端口来连接ftp connect_from_port_20=YES# 使用标准日志格式 xferlog_std_format=YES# 如果启动这项功能，则所有列在chroot_list_file之中的使用者不能更改根目录chroot_list_enable=YES# 指定限制的用户文件chroot_list_file=/etc/vsftpd.chroot_list# ftp服务器将处于独立启动模式listen=YES# 设置一个本地用户登录后进入到的目录local_root=/home/uftp/ftpfile# 设置PAM认证服务的配置文件名称，该文件保存在“/etc/pam.d/”目录下pam_service_name=vsftpd# ftp将检查userlist_file设置文件中指定的用户是否可以访问vsftpd服务器userlist_enable=YES# 只允许user_list文件中记录的ftp用户能登录vsftp服务，其他的ftp用户都不可以登录。userlist_deny=NO 权限配置需要手动创建一个根目录，用户可以访问该目录下的资源 1234// 创建用户并指定家目录$ useradd -d /home/uftp -m -s /bin/bash uft// 修改密码$ passwd uftp 新建文件添加允许登录的用户，并将用户名键入如下文件（文件名和配置文件中的配置保持一致） 1$ vi /etc/vsftpd.chroot_list 启动停止重启服务123$ sudo /etc/init.d/vsftpd start$ sudo /etc/init.d/vsftpd stop$ sudo /etc/init.d/vsftpd restart 完成 ftp常用命令示例建立连接,输入账户密码并开启passive模式 12345678910111213$ ftpftp&gt; open 122.51.243.174Connected to 122.51.243.174.220 (vsFTPd 3.0.3)Name (122.51.243.174:fibos): uftp331 Please specify the password.Password:230 Login successful.// 开启passive模式ftp&gt; quote pasv227 Entering Passive Mode (122,51,243,174,226,24).ftp&gt; passivePassive mode on. 上传下载12345678910111213// 下面可指定默认下载到哪个目录，如不指定默认当前$ lcd /home/user/yourdirectoryname// 下载文件$ get file// 批量下载示例$ mget *.html// 上传$ put file// 批量上传示例$ mput *.html// 退出$ exit 更多命令执行： 12345678910111213141516171819ftp&gt; helpCommands may be abbreviated. Commands are:! dir macdef proxy site$ disconnect mdelete sendport sizeaccount epsv4 mdir put statusappend form mget pwd structascii get mkdir quit systembell glob mls quote suniquebinary hash mode recv tenexbye help modtime reget tracecase idle mput rstatus typecd image newer rhelp usercdup ipany nmap rename umaskchmod ipv4 nlist reset verboseclose ipv6 ntrans restart ?cr lcd open rmdirdelete lpwd passive runiquedebug ls prompt send 常见问题终端未安装ftpcommand not found: ftp 你需要在你的电脑中安装ftp工具，执行如下代码（mac）： 123brew install telnet;brew install inetutils;brew link --overwrite inetutils; 耐心等待安装完毕即可。 上传文件失败原因： ftp用户无上传权限解决： root用户登陆服务器，vi /etc/vsftpd.conf，将write_enable=YES配置的注释取消，：wq 保存，然后执行/etc/init.d/vsftpd restart重启服务即可","link":"/2019/11/05/Ubuntu%E4%B8%AD%E4%BD%BF%E7%94%A8FTP%E6%9C%8D%E5%8A%A1/"},{"title":"Ubuntu中使用SFTP服务","text":"SFTP介绍sftp是Secure File Transfer Protocol的缩写，安全文件传送协议。可以为传输文件提供一种安全的网络的加密方法。sftp 与 ftp 有着几乎一样的语法和功能。SFTP 为 SSH的其中一部分，是一种传输档案至 Blogger 伺服器的安全方式。其实在SSH软件包中，已经包含了一个叫作SFTP(Secure File Transfer Protocol)的安全文件信息传输子系统，SFTP本身没有单独的守护进程，它必须使用sshd守护进程（端口号默认是22）来完成相应的连接和答复操作，所以从某种意义上来说，SFTP并不像一个服务器程序，而更像是一个客户端程序。SFTP同样是使用加密传输认证信息和传输的数据，所以，使用SFTP是非常安全的。但是，由于这种传输方式使用了加密/解密技术，所以传输效率比普通的FTP要低得多，如果您对网络安全性要求更高时，可以使用SFTP代替FTP. 安装步骤目标 在Ubuntu系统上开通sftp文件服务，允许某些用户上传及下载文件。但是这些用户只能使用sftp传输文件，不能使用SSH终端访问服务器，并且sftp不能访问系统文件。系统管理员则既能使用sftp传输文件，也能使用SSH远程管理服务器。 以下是将允许sftp-users用户组内的用户使用sftp，但不允许使用SSH Shell，且该组用户不能访问系统文件。在sftp-users组内创建一个用户“sftp”。允许ssh-users用户组内的用户使用sftp以及SSH。系统管理员的账户名为bbc2005。 Ubuntu系统信息查看当前系统版本： 1$ cat /etc/*release 查看是否安装了SFTP在Linux系统中，一般RedHat系统默认已经安装了openssh-client和openssh-server，即默认已经集成了sftp服务，不需要重新安装；而Ubuntu系统默认只安装了openssh-client，要用sftp的话还需要安装openssh-server。如系统已安装有openssh-client，为了防止安装openssh-server时两者版本不兼容，可以先把openssh-client卸载后再安装。查看本系统是否已安装sftp，执行如下命令： 1$ dpkg --get-selections | grep ssh 若未安装： 执行下文安装操作 安装openssh-client1$ sudo apt-get install openssh-client 安装完成后执行之前的命令查看： 安装openssh-server执行命令: 1$ sudo apt-get install openssh-server 查看是否成功： 权限配置创建sftp-users用户组，并新建用户sftp12345678$ sudo addgroup sftp-usersAdding group 'sftp-users' (GID 1001)...Done.$ sudo adduser sftp............ 给sftp赋权并新建用户组ssh-users将sftp从所有其他用户组中移除并加入到sftp-users组，并且关闭其Shell访问： 1$ sudo usermod -G sftp-users -s /bin/false sftp 创建SSH用户组，并把管理员加入到该组（注意usermod中的-a参数的意思是不从其他用户组用移除）。 12$ sudo addgroup ssh-users$ sudo usermod -a -G ssh-users bbc2005 创建并设置sftp用户目录准备“监狱”的根目录及共享目录，“监狱”的根目录必须满足以下要求：所有者为root，其他任何用户都不能拥有写入权限。因此，为了让sftp用户能够上传文件，还必须在“监狱”根目录下再创建一个普通用户能够写入的共享文件目录。为了便于管理员通过sftp管理上传的文件，把这个共享文件目录配置为：由bbc2005所有，允许sftp-users读写。这样，管理员和sftp用户组成员就都能读写这个目录了。 1234$ sudo mkdir /home/sftp_root$ sudo mkdir /home/sftp_root/shared$ sudo chown bbc2005:sftp-users /home/sftp_root/shared$ sudo chmod 770 /home/sftp_root/shared 修改SSH配置文件1$ vi /etc/ssh/sshd_config 在sshd_config文件的最后，添加以下内容： 123456AllowGroups ssh-users sftp-usersMatch Group sftp-usersChrootDirectory /home/sftp_rootAllowTcpForwarding noX11Forwarding noForceCommand internal-sftp 这些内容的意思是：只允许ssh-uers及sftp-users通过SSH访问系统；针对sftp-users用户，额外增加一些设置：将“/home/sftp_root”设置为该组用户的系统根目录（因此它们将不能访问该目录之外的其他系统文件）；禁止TCP Forwarding和X11 Forwarding；强制该组用户仅仅使用SFTP。如果需要进一步了解细节，可以使用“man sshd_config”命令。这样设置之后，SSH用户组可以访问SSH，并且不受其他限制；而SFTP用户组仅能使用SFTP进行访问，而且被关进监狱目录。 重启重启服务，完成配置： 1$ service ssh restart 常用命令sftp 连接键入以下命令，输入密码即可 1sftp youruser@ip sftp下载及上传从120.110.7.119服务器的 /etc/supervisor 目录下的 file.conf 文件下载到 本地服务器的 /etc/supervisord.d 目录下 1$ sftp&gt; get /etc/supervisor/file.conf /etc/supervisord.d 加上 -r 标记，表示从远程服务器的 /home/data 文件夹下载到本地服务器的 /home/my 目录下。 1$ sftp&gt; get -r /home/data /home/my 将本地的Linuxgl.pdf 文件上传到 远程的 /var/www/fuyatao 目录下 1$ put /home/fuyatao/downloads/Linuxgl.pdf /var/www/fuyatao/ 将本地的 fuyatao 文件夹上传到 远程的 /var/www/fuyatao 目录下 1$ put -r /home/fuyatao /var/www/fuyatao/ 更多用法可输入help查看或百度","link":"/2019/11/04/Ubuntu%E4%B8%AD%E4%BD%BF%E7%94%A8SFTP%E6%9C%8D%E5%8A%A1/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post 1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/10/28/hello-world/"},{"title":"SystemContract","text":"newaccount 创建合约账户 参数 name type description creator string 创建者的账户名 name string 被创建者的账户名 owner string 被创建者账户 owner 权限公钥 active string 被创建者 active 权限公钥 示例1234567891011121314151617181920const FIBOS = require('fibos.js');const fibos_client = FIBOS({ // fibos 测试网 chainId chainId: '68cee14f598d88d340b50940b6ddfba28c444b46cd5f33201ace82c78896793a', keyProvider: 'PRIVATE_KEY', // 你的私钥 httpEndpoint: 'http://api.testnet.fo',});let ctx = fibos_client.contractSync('eosio');var r = ctx.newaccountSync({ creator:'eosio', name:'NEW_ACCOUNT_NAME', owner:'PUBLIC_KEY_FOR_OWNER_PERMISSION', active:'PUBLIC_KEY_FOR_ACTIVE_PERMISSION'},{ authorization: 'ACCOUNT_FOR_PRIVATE_KEY' // 私钥对应的账号});console.log(r); buyrambytes 创建者调用该方法为被创建者购买内存来存放新账户的信息 参数 name type description payer string 创建者的账户名 receiver string 被创建者的账户名 bytes uint32 购买的内存大小（字节） 示例12345678910111213141516171819const FIBOS = require('fibos.js');const fibos_client = FIBOS({ // fibos 测试网 chainId chainId: '68cee14f598d88d340b50940b6ddfba28c444b46cd5f33201ace82c78896793a', keyProvider: 'PRIVATE_KEY', // 你的私钥 httpEndpoint: 'http://api.testnet.fo',});let ctx = fibos_client.contractSync('eosio');var r = ctx.buyrambytesSync({ payer: 'ACCOUNT_OF_PAYER', receiver: 'ACCOUNT_OF_RECEIVER', bytes: 4096},{ authorization: 'ACCOUNT_FOR_PRIVATE_KEY' // 私钥对应的账号});console.log(r); delegatebw 抵押通证获取 cpu 和带宽资源 参数 name type description from string 资源抵押者的账户名 receiver string 资源接受者的账户名 stake_net_quantity string 抵押者为接受者抵押 FO 获取 NET stake_cpu_quantity string 抵押者为接受者抵押 FO 获取 CPU transfer bool 代表抵押资源同时是否将对应通证转账给接受者 示例123456789101112131415161718192021const FIBOS = require('fibos.js');const fibos_client = FIBOS({ // fibos 测试网 chainId chainId: '68cee14f598d88d340b50940b6ddfba28c444b46cd5f33201ace82c78896793a', keyProvider: 'PRIVATE_KEY', // 你的私钥 httpEndpoint: 'http://api.testnet.fo',});let ctx = fibos_client.contractSync('eosio');var r = ctx.delegatebwSync({ from: 'ACCOUNT_OF_MORTGAGOR', receiver: 'ACCOUNT_OF_RECEIVER', stake_net_quantity: '3193.0000 FO', stake_cpu_quantity: '30000.0000 FO', transfer: 0},{ authorization: 'ACCOUNT_FOR_PRIVATE_KEY' // 私钥对应的账号});console.log(r); claimrewards 区块生产者领取工资 参数 name type description owner string 区块生产者名称 示例1234567891011121314151617const FIBOS = require('fibos.js');const fibos_client = FIBOS({ // fibos 测试网 chainId chainId: '68cee14f598d88d340b50940b6ddfba28c444b46cd5f33201ace82c78896793a', keyProvider: 'PRIVATE_KEY', // 你的私钥 httpEndpoint: 'http://api.testnet.fo',});let ctx = fibos_client.contractSync('eosio');var r = ctx.claimrewardsSync({ owner: 'ACCOUNT_OR_OWNER'},{ authorization: 'ACCOUNT_FOR_PRIVATE_KEY' // 私钥对应的账号});console.log(r);","link":"/2019/10/29/fibos-SystemContract/"},{"title":"深度共享定义","text":"产品定义共享前深度：各交易所真实的盘口数据目标深度：期望达到的最小预期深度共享后深度：实际真实布单后的深度，称之为共享后深度 数据算法1: 全网共享前深度：单个交易所共享前深度数据相加2: 单个交易所共享前深度：实际从各个交易所取回的真实数据3: 全网目标深度：从盘口价取正负20%的数据，分为20档，每档价格退3%，形成全网目标深度数据4: 单个交易所目标深度：全网总目标深度数据*单个交易所系数（系数为人工设置，可能各交易所不同）5: 全网共享后深度：单个交易所共享后深度相加6: 单个交易所共享后深度：共享前深度+布单深度7: 布单规则：将数据分为20档，每档若共享前深度小于目标深度，则补差额=目标深度-共享前深度，若共享前深度大于目标深度，则不用再该档布单，并在后一档将多出的数量减去 代码depthshare布单patchorder补单other方法1: getHuobiUsdtPrice获取火币价格2:","link":"/2019/11/18/%E6%B7%B1%E5%BA%A6%E5%85%B1%E4%BA%AB/"},{"title":"泰得","text":"1: 在前端将支付成功的trx_id发送给后端后，拿trx_id去事务表查询 2: 将链上的转账信息存入流水表pay中，pay表字段如下： | from | to | currency | amout | createtime | memo | tranId || — | — | — | — | — | — | — | — || 转账者 | 接受者账号 | 币种 | 金额 | 创建时间 | memo(含orderId） | 事务ID | 3: 流水表pay和订单表orders通过order.Id进行关联orderId和前端约定为order_xxxx格式 4: 用户付款后，前端发送订单信息，根据orderId关联查询orders和pay中是否有相关记录，有则修改支付状态为成功，否则返回失败 PS：1: 事务表关联检车区块表，等待2分48秒去区块表查询区块状态确认为不可逆才能确认支付成功2分48秒后不停去查询可逆状态，如果30秒内查询到的都是可逆状态，那么区块出问题了，返回给前端，让前端手动确认交易成功，后端接受后直接判定支付成功","link":"/2019/12/31/%E6%B3%B0%E5%BE%97/"},{"title":"深度共享V2","text":"动态布单实现方案原方案（非动态）：1: 流程开始，批量全部撤单2: 风控检测，获取用户盘口，计算深度数据3: 根据深度数据计算交叉比率，根据交叉比率判断是否进行交叉消除，若交叉消除则不走补，布单，直接转至step5，否则下一步4: 补单 =》 布单5: 随机判断是否执行跑量脚本6: END 目标效果：解决原方案中同时出现大量的撤单，布单现象，实现随机撤，布单 目标方案A：1: 流程开始不撤单，取所有挂单集合A2: 进行风控检测，获取用户盘口，根据第一步取到的挂单在用户盘口中排除部分深度数据，得到总盘口ex3: 根据总盘口ex计算深度数据，并根据深度数据计算交叉比率判断是否进行交叉消除，若交叉消除则将交叉单数组C与挂单集合A随机组合进行撤布单,转至step5；不交叉消除则执行step44: 不交叉消除，进行补单操作，再根据深度数据计算需要布单的数组B，将A，B两个数组随机合并，进行撤，布单。5: 随机判断是否执行跑量脚本6: END 问题1: 如何剔除初始盘口中的已挂单深度数据 比如AEX交易所中已挂单返回结果是： 是否根据一个 { price，amount，type }来确定筛除一个bid或者一个ask。 Answer:将返回的orderList封装成bids和asks的数组格式A，遍历A，从深度数据数组中移除等量的orders price和amount，达到完全将A清空。排除完成。 2: 原流程中撤单有失败流程直接结束，动态布单中若撤单失败，是结束流程还继续布单 3: 根据挂单剔除深度是否根据不同交易所来剔除，例如aex的挂单要在aexDepth中剔除Answer： 根据不同交易所分开来剔除深度，剔除方向由高往低或者由低往高都可以 深度共享 动态布单方案：step1: 首先套利（交叉消除），撤掉自己的在套利区间内的挂单，再交叉消除，1秒1次计算出交叉消除区间后，在交叉消除前撤掉自己区间内的挂单，避免自己跟自己成交 step2: 补单，在补单区间内撤掉自己的单，然后进行补单操作，1秒1次在计算出补单额度后，在进行补单前撤掉自己在补单区间内的挂单，避免自己跟自己成交 step3: 撤/布单（调单：先算目标深度、基础深度）待撤单：撤掉各个交易所账户中所有本轮中目标深度与现有挂单不一致的应撤挂单待布单：根据目标深度计算出应布单将应撤，布单根据随机排序组合打乱然后进行撤布单操作。 撤布单实现步骤： 步骤1: 实时获取当前账户的挂单数组A（待撤单），计算出当前目标深度应布单数组B（待挂单） 步骤2: 计算当前挂单A中待撤单与B中待挂单价位是否交叉，若同价位同数量单在A，B中都存在，则将该单从A，B中剔除。若同价位，撤单与挂单数量不一致则根据情况在A或B中剔除。 步骤3: 将计算完后的A，B随机组合，在接下来的8秒内分散进行撤单及布单PS： 1: 套利和补单操作需要在1S的计时器中执行 2: 在套利，补单完成后 深度共享 动态布单方案：step1: 首先套利（交叉消除），撤掉自己的在套利区间内的挂单，再交叉消除，1秒1次计算出交叉消除区间后，在交叉消除前撤掉自己区间内的挂单，避免自己跟自己成交 step2: 补单，在补单区间内撤掉自己的单，然后进行补单操作，1秒1次在计算出补单额度后，在进行补单前撤掉自己在补单区间内的挂单，避免自己跟自己成交 step3: 撤/布单 步骤1: 拿实际深度跟目标深度比，将二者按小数点后四位合并（0.009871，0.009872==》0.00987），比较二者同档位数量，若实际深度比目标深度高则撤掉多出的部分，反之则布相应数量的单。 步骤2: 撤，布单顺序按照数量差额从大到小排序 问题：1:之前目标深度的算法（取dex交易所lastprice价格按20%幅度分档）得出的目标深度与现布单策略不匹配，导致目标深度和实际深度中没有同价位的深度 2:存在目标深度与实际深度价位 不匹配的项是否直接跳过。 3:撤/布单是否单独列入计时器中 与 套利补单互斥执行。 深度共享 动态布单方案：step0: 判断是第一轮共享，是则把所有挂单都撤掉step1: 首先套利（交叉消除），撤掉自己的在套利区间内的挂单，再交叉消除，1秒1次计算出交叉消除区间后，在交叉消除前撤掉自己区间内的挂单，避免自己跟自己成交 step2: 补单，在补单区间内撤掉自己的单，然后进行补单操作，1秒1次在计算出补单额度后，在进行补单前撤掉自己在补单区间内的挂单，避免自己跟自己成交 step3: 撤/布单 第一轮: 取dex的lastprice，根据上下20%分成20档得出目标深度，根据目标深度进行布单 第N 轮: 拿个人当前挂单深度跟根据目标深度算出的待挂单深度比，将二者按小数点后四位合并（0.009871，0.009872==》0.00987，精度后面的数直接丢掉，最后一位卖进一，买减一），比较二者同档位数量，若实际深度比目标深度高则撤掉该单，反之则布二者差额数量的单，二者皆仅取最大值的那一单。 step5: 1～50随机执行一次跑量脚本step4: 深度共享周期由10s调整为1s，跑量频率对应要降低 问题：1:之前目标深度的算法（取dex交易所lastprice价格按20%幅度分档）得出的目标深度与现布单策略不匹配，导致目标深度和实际深度中没有同价位的深度 2:存在目标深度与实际深度价位 不匹配的项是否直接跳过。 3:撤/布单是否单独列入计时器中 与 套利补单互斥执行。 补单系数需求开发原始需求：在补单时，各个交易所的实际补单数量=原始值*补单系数，并且在补完单后初始FO总数要随上一轮忽略的补单值而变动，补单系数可以在页面上进行配置。 开发方案：在补单过程patchOrder中新增系数配置，根据不同交易所的不同系数进行补单，补单结束后同步更新配置文件/conf/config.js中的totalfo=totalfo+-差额（根据实际情况）。 进度： 开发已完成，测试环境试运行 深度共享配置页面化原始需求：将深度共享的配置项文件/conf/config.js中的配置项展示到页面上来，并可以在页面上对其进行修改且实时生效 开发方案：在server.js中新增/showconf，/updateconf两个接口分别用于展示和修改配置文件/conf/config.json，在testdepth.js中，每一轮都重新读取config.json的值执行深度共享 进度： 开发已完成，测试账号正常运行。","link":"/2019/12/10/%E6%B7%B1%E5%BA%A6%E5%85%B1%E4%BA%AB%E5%8A%A8%E6%80%81%E5%B8%83%E5%8D%95/"},{"title":"深度共享需求","text":"2019-11-25日 卖单校验：问题：卖单时未对交易结果进行校验，卖出失败流程依然继续买入操作，导致亏损解决方案：1：globalTrade方法添加返回值，交易成功设true，失败为false,dex交易所根据交易前余额，其余根据返回码判断。 实现： 1234567891011121314151617181920let r = aex.submitOrder(cny, type, amout, _price, fo); if(r.code &amp;&amp; r.code!=220010) bol = false;............var before = utils.getBalance(dex,\"dex\"); dex.submitOrder(direct, amout, price); var after = utils.getBalance(dex,\"dex\"); try { if(direct == \" \"){ if(!(bigNumber[\"&lt;\"](before.fo,after.fo)&amp;&amp;bigNumber[\"&gt;\"](before.usdt,after.usdt))) // 买单failed bol = false; }else{ if(!(bigNumber[\"&gt;\"](before.fo,after.fo)&amp;&amp;bigNumber[\"&lt;\"](before.usdt,after.usdt))) // 卖单failed bol = false; } } catch (error) { console.warn(\"get balance error\", e); bol = false; } 2：补单代码中，循环卖出时判断若有一次交易失败，结束流程等待下一轮 根据成交单刷新流程：问题：目前整个流程周期为10秒，在这个过程中，交易所可能发生其他交易导致我们流程的数据会不可靠，如果把10秒时间调短则高频布单对交易所api效果很差 解决方案：通过一个快速（比如2秒周期）订单查询服务判断有单成交时（通过判断2秒前的成交订单和本次轮训的成交订单记录是否一致），直接刷新目前流程，重新计时开始布单撤单。任一交易所有成交订单都会刷新 可能遇到的问题： 1：当查询事件查询到已成交订单时，当前testdepth流程正在执行（比如正在买卖单），是否要等待正在进行的流程执行完。answer：设置全局flag=true，交易开始置为false，结束置true，查询定时器中根据flag判断是否重启原进程 2：如何判断上一轮的成交订单和这本次查询结果不一致，取多少条成交订单进行判断，判断交易ID？answer：有些交易所的交易ID不是规则的，因此用交易时间来判断，取10条记录即可 步骤：1：2秒一次抓取各交易所成交数据存入数据库中，字段如下： k datetime v status aex 2019-08-07 16:10:30 […] — cointiger 2019-08-07 16:10:30 […] — 2：对前后两次交易进行比较（时间戳），若有新成交的订单则重启撤布单流程，否则继续。zg,dex交易所不参与。 2020年1月6号补单系数需求开发原始需求：在补单时，各个交易所的实际补单数量=原始值*补单系数，并且在补完单后初始FO总数要随上一轮忽略的补单值而变动，补单系数可以在页面上进行配置。 开发方案：在补单过程patchOrder中新增系数配置，根据不同交易所的不同系数进行补单，补单结束后同步更新配置文件/conf/config.js中的totalfo=totalfo+-差额（根据实际情况）。 深度共享配置页面化原始需求：将深度共享的配置项文件/conf/config.js中的配置项展示到页面上来，并可以在页面上对其进行修改且实时生效 开发方案：在server.js中新增/showconf，/updateconf两个接口分别用于展示和修改配置文件/conf/config.json，在testdepth.js中，每一轮都重新读取config.json的值执行深度共享 进度： 开发已完成，测试账号正常运行。","link":"/2019/11/26/%E6%B7%B1%E5%BA%A6%E5%85%B1%E4%BA%AB%E9%9C%80%E6%B1%82/"}],"tags":[{"name":"d3j","slug":"d3j","link":"/tags/d3j/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"-hello","slug":"hello","link":"/tags/hello/"}],"categories":[{"name":"fibos","slug":"fibos","link":"/categories/fibos/"},{"name":"study","slug":"study","link":"/categories/study/"}]}